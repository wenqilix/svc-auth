package auth.service

import java.nio.file.Files
import java.nio.file.Paths
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.bind.annotation.CrossOrigin
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.ResponseEntity
import org.springframework.http.HttpStatus
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import com.fasterxml.jackson.databind.ObjectMapper
import auth.helper.Jwt
import auth.helper.Properties
import auth.helper.SignatureAuthenticator
import auth.service.model.Service
import auth.service.model.Payload

@RestController("serviceRestController")
@CrossOrigin
class ApiController {

    @Autowired
    lateinit var jwt: Jwt

    @Autowired
    lateinit var signatureAuthenticator: SignatureAuthenticator

    @Autowired
    lateinit var properties: Properties

    internal val servicesConfig by lazy {
        properties.service!!
    }

    companion object {
        val services: MutableList<Service> = mutableListOf()
    }

    fun getServiceConfig(serviceId: String): Service {
        val mapper = ObjectMapper(YAMLFactory())

        val file = Paths.get(servicesConfig.servicesFolderPath + "/" + serviceId + ".yaml")

        return Files.newBufferedReader(file).use {
            mapper.readValue(it, Service::class.java)
        }
    }

    fun getService(serviceId: String): Service {
        val service = services.find { it.guid == serviceId }

        if (service == null) {
            val newService = this.getServiceConfig(serviceId)
            services.add(newService)
            return newService
        } else {
            return service
        }
    }

    // Session id is a random string generated by requesting user that is part of the signature
    @GetMapping("{issuer}/login")
    fun token(
        @RequestHeader(value = "username") serviceId: String,
        @RequestHeader(value = "signature") signature: String,
        @RequestHeader(value = "nonce") nonce: String,
        @PathVariable issuer: String
    ): ResponseEntity<Any> {
        val body = HashMap<String, Any?>()
        val service: Service

        try {
            service = getService(serviceId)

            val isValidNonce = signatureAuthenticator.verifyNonce(nonce)
            val isValidSignature = signatureAuthenticator.verifyService(nonce, signature, service)

            if (!isValidNonce || !isValidSignature) {
                body.put("error", "invalid service identifier")
                return ResponseEntity<Any>(body, HttpStatus.UNAUTHORIZED)
            }
        } catch (e: Exception) {
            body.put("error", e.message)
            return ResponseEntity<Any>(body, HttpStatus.BAD_REQUEST)
        }

        val payload = Payload(service.payload)
        return ResponseEntity<Any>(jwt.build(issuer, payload.toMap()), HttpStatus.OK)
    }
}
